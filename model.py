# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12CIMLQ7kBil77-VTcqf-YtGqCiZ7eAvT
"""

import pandas as pd

dataset = pd.read_csv('master.csv')
dataset.rename(columns={'year': 'ano', 'suicides_no': 'num_suicidios', 'population': 'populacao', 'suicides/100k pop': 'suicidios_pop_100k', 
                        'HDI for year': 'HDI_por_ano', 'gdp_per_capita ($)': 'gdp_per_capita'}, inplace=True)
dataset.corr()

import seaborn as sns

sns.pairplot(x_vars=['ano', 'populacao', 'suicidios_pop_100k', 'HDI_por_ano', 'gdp_per_capita'], 
             y_vars='num_suicidios', data=dataset, kind='reg', height=3.2)

dataset.hist(bins=50, figsize=(10, 10))

dataset = dataset[(dataset['num_suicidios'] > 0) & (dataset['suicidios_pop_100k'] > 0)]

from sklearn.preprocessing import PowerTransformer
power_x = PowerTransformer(method='box-cox')
power_y = PowerTransformer(method='box-cox')

X_vars = dataset[['HDI_por_ano', 'ano', 'gdp_per_capita', 'populacao', 'suicidios_pop_100k']]
y_vars = dataset[['num_suicidios']]

X_trans = power_x.fit_transform(X_vars)
y_trans = power_y.fit_transform(y_vars)

dataset_trans = pd.DataFrame(data=X_trans, columns=['HDI_por_ano', 'ano', 'gdp_per_capita', 'populacao', 'suicidios_pop_100k'])
dataset_trans['num_suicidios'] = y_trans

dataset_trans.dropna(inplace=True)

# Importando a biblioteca statsmodels
import statsmodels.api as sm
# Separando os dados transformados em X e y
X_sm = dataset_trans[['HDI_por_ano', 'ano', 'gdp_per_capita', 'populacao', 'suicidios_pop_100k']]
y_sm = dataset_trans['num_suicidios']
# Adicionando coeficiente as variáveis independentes
X_sm = sm.add_constant(X_sm)
# Treinando o modelo
model_sm = sm.OLS(y_sm, X_sm).fit()
# Visualizando as estatística do modelo treinado
model_sm.summary()

# Utilizando a classe LinearRegression do pacote linear_model
from sklearn.linear_model import LinearRegression
# Importando o método train_test_split para separar os dados entre treino e teste
from sklearn.model_selection import train_test_split
# Separando os dados em treino e teste
# Separando os dados transformados em X e y
X = dataset_trans[['HDI_por_ano', 'ano', 'gdp_per_capita', 'populacao', 'suicidios_pop_100k']]
y = dataset_trans['num_suicidios']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
# Treinando o modelo com os conjuntos de treino
lin_reg = LinearRegression()
model = lin_reg.fit(X_train, y_train)

# Commented out IPython magic to ensure Python compatibility.
# Gerando as previsões
y_pred = model.predict(X_test)
# Obtendo os resíduos
residuals = y_test - y_pred
# Plotando o valor previsto x valor real, a relação entre os dois deve ser linear
# Para isso utilizaremos a biblioteca matplotlib
import matplotlib.pyplot as plt
# %matplotlib inline
ax = plt.scatter(y_pred, y_test)
ax.figure.set_size_inches(12, 6)
plt.title('Previsão x Real', fontdict={'fontsize': 16})
plt.xlabel('Suicídios - Previsão', fontdict={'fontsize': 16})
plt.ylabel('Suicídios - Real', fontdict={'fontsize': 16})
ax
# Importando o módulo metrics para as avaliações do modelo
import sklearn.metrics as metrics
# Mostrando o valor do R²
print('R² =', metrics.r2_score(y_true=y_test, y_pred=y_pred))

ax = plt.scatter(x=y_pred, y=residuals)
ax.figure.set_size_inches(12, 6)
plt.title('Previsão x Resíduos', fontdict={'fontsize': 16})
plt.xlabel('Suicídios - Previsão', fontdict={'fontsize': 16})
plt.ylabel('Resíduos', fontdict={'fontsize': 16})
ax